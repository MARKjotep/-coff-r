// @bun
import{existsSync as M,mkdirSync as Q}from"fs";var r=(x)=>{if(M(x))return!0;return Q(x,{recursive:!0}),!0},O=(x)=>{let S=new Date().toLocaleTimeString();console.log(`${x} @ ${S}`)};import{watch as U}from"fs";import{readdir as V,rm as W,stat as X,unlink as Y}from"fs/promises";import Z from"path";class y{dir;out;minify;hashAsset;drop;files;external;plugins;exclude=[];target;define={};clearing=!1;successFN;constructor({files:x,target:S="bun",dir:C="./src",out:m,base:$="",define:L={},external:D=[],drop:E=[],plugins:G=[],hashAsset:q,minify:I={},successFN:J}){this.target=S,this.dir=C+$,this.out=(m?m:S==="browser"?"./client":"./dist")+$,this.files=x.map((K)=>(this.dir+"/"+K).replaceAll("//","/")),r(this.out),this.hashAsset=q===void 0?!1:q,this.minify={identifiers:!0,whitespace:!0,syntax:!0},this.external=D,this.drop=E,this.plugins=G,this.successFN=J,Object.assign(this.minify,I),Object.assign(this.define,L)}set onsuccess(x){this.successFN=x}async build(){let x=`[dir]/[name]${this.hashAsset?"-[hash]":""}.[ext]`;if(this.files.length)try{let S=await Bun.build({entrypoints:this.files,outdir:this.out,splitting:!0,minify:this.minify,target:this.target??"browser",naming:{chunk:"[dir]/[name]-[hash].[ext]",entry:"[dir]/[name].[ext]",asset:x},define:{...c(this.define)},loader:{".css":"file"},external:this.external,drop:this.drop,plugins:this.plugins});if(S.success)try{await this.successFN?.(),O("builder")}catch(C){console.log(C)}else console.log(S.logs)}catch(S){console.log(S)}return this}async watch(x=()=>!0){let S=U(this.dir,{recursive:!0},async(C,m)=>{if(m&&x(m)){this.clearing&&this.clear();try{await this.build()}catch($){console.error($)}}});process.on("SIGINT",()=>{console.log(`
watcher closed...`),S.close(),process.exit(0)})}async clear(x={exclude:[],all:!1}){x.exclude&&x.exclude.length&&this.exclude.push(...x.exclude),this.clearing=!0;let S=async(C)=>{let m=await V(C);if(m.length==0){await W(C,{recursive:!0});return}for(let $ of m){if($.startsWith(".")||!x.all&&($.endsWith(".html")||this.exclude.includes($)))return;let L=Z.join(C,$);if((await X(L)).isDirectory())await S(L);else await Y(L)}};return await S(this.out),this}}var c=(x)=>{return Object.fromEntries(Object.entries(x).map(([S,C])=>{let m=C;if(typeof C==="function")m=C();return[S,JSON.stringify(m)]}))};import{rollup as w}from"rollup";import{dts as j}from"rollup-plugin-dts";class z{log;options;constructor(x){x.plugins=x.plugins?Array.isArray(x.plugins)?[...x.plugins,j()]:[x.plugins,j()]:[j()];let{log:S,...C}=x;this.options=C,this.log=Boolean(S),delete x.log}async output(x){try{let S=await w(this.options);await S.write(x),await S.close(),this.log&&O("rollup")}catch(S){console.error("Build failed:",S)}}}async function B(x,S){let C=x.split(";");for(let m of C){let $=m.trim().split(" ");await Bun.spawn($).exited}S&&O("cmd")}export{z as Roll,y as Oven,B as Cmd};
